<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VoIP Audio Call</title>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, deleteDoc } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

        // Firebase config
        const firebaseConfig = {
            apiKey: "AIzaSyB_oIgWVcb_56VAdWaVl7GHY3bj75Vt-Wo",
            authDomain: "testcaller-91d8c.firebaseapp.com",
            projectId: "testcaller-91d8c",
            storageBucket: "testcaller-91d8c.firebasestorage.app",
            messagingSenderId: "368258808732",
            appId: "1:368258808732:web:edc101575b7f6266182659"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let localStream;
        let remoteStream = new MediaStream();
        let pc;
        let targetEmail; // For caller
        let fromEmail; // For callee
        const remoteAudio = document.getElementById('remoteAudio');
        remoteAudio.srcObject = remoteStream;

        // Authenticate user
        async function signIn(email, password) {
            try {
                await signInWithEmailAndPassword(auth, email, password);
                console.log('Signed in as', email);
            } catch (error) {
                console.error('Sign-in error:', error);
            }
        }

        // Create RTCPeerConnection
        function createPeerConnection() {
            pc = new RTCPeerConnection();
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    // Send ICE candidate to Firestore (serialized)
                    setDoc(doc(db, 'calls', 'ice-' + auth.currentUser.email), { candidate: event.candidate.toJSON() });
                }
            };
            pc.ontrack = (event) => {
                remoteStream.addTrack(event.track);
            };
            // Add local audio tracks
            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
        }

        // Start call (caller)
        async function startCall(target) {
            targetEmail = target;
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            createPeerConnection();
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            // Send offer to Firestore (serialized)
            await setDoc(doc(db, 'calls', 'offer'), { offer: offer.toJSON(), from: auth.currentUser.email });
            // Listen for answer
            onSnapshot(doc(db, 'calls', 'answer'), (docSnap) => {
                if (docSnap.exists() && pc.signalingState !== 'stable') {
                    const data = docSnap.data();
                    pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                    // Clean up after setting
                    deleteDoc(doc(db, 'calls', 'offer'));
                    deleteDoc(doc(db, 'calls', 'answer'));
                }
            });
            // Listen for ICE from callee
            onSnapshot(doc(db, 'calls', 'ice-' + targetEmail), (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                }
            });
        }

        // Answer call (callee)
        async function answerCall() {
            localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            // Listen for offer
            onSnapshot(doc(db, 'calls', 'offer'), async (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    fromEmail = data.from;
                    createPeerConnection();
                    await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    // Send answer (serialized)
                    await setDoc(doc(db, 'calls', 'answer'), { answer: answer.toJSON() });
                    // Listen for ICE from caller
                    onSnapshot(doc(db, 'calls', 'ice-' + fromEmail), (docSnap) => {
                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                        }
                    });
                    // Clean up after setting
                    deleteDoc(doc(db, 'calls', 'offer'));
                    deleteDoc(doc(db, 'calls', 'answer'));
                }
            });
        }

        // UI elements
        document.getElementById('signIn1').onclick = () => signIn('t1@test.com', '111111');
        document.getElementById('signIn2').onclick = () => signIn('t2@test.com', '111111');
        document.getElementById('startCall').onclick = () => startCall('t2@test.com'); // From t1
        document.getElementById('answerCall').onclick = () => answerCall(); // For t2

        // No global listeners on auth change to avoid conflicts
    </script>
</head>
<body>
    <button id="signIn1">Sign in as t1@test.com</button>
    <button id="signIn2">Sign in as t2@test.com</button>
    <button id="startCall">Start Call (from t1 to t2)</button>
    <button id="answerCall">Answer Call (as t2)</button>
    <audio id="remoteAudio" autoplay></audio>
</body>
</html>
